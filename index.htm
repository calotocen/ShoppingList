<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>買い物リスト</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
          integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
    <style>
        .outline-none {
            outline: none;
        }

        .dvw-75 {
            width: 75dvw;
        }

        .dvh-100 {
            height: 100dvh;
        }

        .bi-fs-1::before {
            font-size: calc(1.375rem + 1.5vw) !important;
        }

        .bi-fs-2::before {
            font-size: calc(1.325rem + 0.9vw) !important;
        }

        .bi-fs-3::before {
            font-size: calc(1.3rem + 0.6vw) !important;
        }

        .bi-fs-4::before {
            font-size: calc(1.275rem + 0.3vw) !important;
        }

        .bi-fs-5::before {
            font-size: 1.25rem !important;
        }

        .bi-fs-6::before {
            font-size: 1rem !important;
        }

        .text-main {
            color: #36b389;
        }

        .bi-text-blue::before {
            color: var(--bs-blue);
        }

        .bg-main {
            background-color: white;
        }

        .btn-main {
            --bs-btn-color: #36b389;
            --bs-btn-bg: transparent;
            --bs-btn-border-color: transparent;
            --bs-btn-hover-color: #40806a;
            --bs-btn-hover-bg: transparent;
            --bs-btn-hover-border-color: transparent;
            --bs-btn-focus-shadow-rgb: none;
            --bs-btn-active-color: #364d45;
            --bs-btn-active-bg: transparent;
            --bs-btn-active-border-color: transparent;
            --bs-btn-active-shadow: none;
            --bs-btn-disabled-color: #333333;
            --bs-btn-disabled-bg: transparent;
            --bs-btn-disabled-border-color: transparent;
        }

        .btn-edit {
            --bs-btn-color: #ffffff;
            --bs-btn-bg: #36b389;
            --bs-btn-border-color: transparent;
            --bs-btn-hover-color: #ffffff;
            --bs-btn-hover-bg: #40806a;
            --bs-btn-hover-border-color: transparent;
            --bs-btn-focus-shadow-rgb: none;
            --bs-btn-active-color: #ffffff;
            --bs-btn-active-bg: #364d45;
            --bs-btn-active-border-color: transparent;
            --bs-btn-active-shadow: none;
            --bs-btn-disabled-color: #ffffff;
            --bs-btn-disabled-bg: #333333;
            --bs-btn-disabled-border-color: transparent;
        }

        .btn-menu {
            --bs-btn-color: #555555;
            --bs-btn-bg: transparent;
            --bs-btn-border-color: transparent;
            --bs-btn-hover-color: #777777;
            --bs-btn-hover-bg: transparent;
            --bs-btn-hover-border-color: transparent;
            --bs-btn-focus-shadow-rgb: none;
            --bs-btn-active-color: #999999;
            --bs-btn-active-bg: transparent;
            --bs-btn-active-border-color: transparent;
            --bs-btn-active-shadow: none;
            --bs-btn-disabled-color: #333333;
            --bs-btn-disabled-bg: transparent;
            --bs-btn-disabled-border-color: transparent;
        }

        .circle-checkbox {
            display: flex;
            position: relative;
            align-items: center;
            column-gap: 0.5rem;
        }

        .circle-checkbox:has(input[type="checkbox"]:not(:checked))::before {
            /* bi-circle */
            content: "\f28a";
        }

        .circle-checkbox:has(input[type="checkbox"]:checked)::before {
            /* bi-check-circle-fill */
            content: "\f26a";

            /* text-main */
            color: #36b389;
        }

        .circle-checkbox:has(input[type="checkbox"]:indeterminate)::before {
            /* bi-dash-circle */
            content: "\f2e6";
        }

        .circle-checkbox:has(input[type="checkbox"]:focus)::before {
            outline: gray dotted;
        }

        .circle-checkbox:has(input[type="checkbox"]:disabled)::before {
            color: gray;
        }

        .circle-checkbox>input[type="checkbox"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 0;
            opacity: 0;
        }

        .list-group-with-horizontal-border-only {
            border-radius: 0;
        }

        .list-group-with-horizontal-border-only>.list-group-item {
            border-width: 0 0 var(--bs-list-group-border-width);
        }

        .list-group-with-horizontal-border-only>.list-group-item:first-child {
            border-top-width: var(--bs-list-group-border-width);
        }

        @keyframes slidein-to-right {
            from {
                transform: translateX(-100%);
            }

            to {
                transform: translateX(0);
            }
        }

        .slidein-to-right {
            animation-name: slidein-to-right;
            animation-fill-mode: forwards;
            animation-duration: 200ms;
            animation-timing-function: ease-out;
        }

        @keyframes live-notification {
            0% {
                transform: translateY(-200%);
            }

            10% {
                transform: translateY(0);
            }

            95% {
                transform: translateY(0);
            }

            100% {
                transform: translateY(-200%);
                display: none;
            }
        }

        .animation-for-live-notification {
            animation-name: live-notification;
            animation-fill-mode: forwards;
            animation-duration: 3000ms;
            animation-timing-function: linear;
        }

        .menu {
            /* 1045 is the z-index value of .offcanvas */
            z-index: 1045;
        }

        .backdrop {
            backdrop-filter: saturate(30%) contrast(60%) blur(2px);
            -webkit-backdrop-filter: saturate(30%) contrast(60%) blur(2px);
        }
    </style>
</head>

<body class="position-relative dvh-100">
    <script src="https://code.jquery.com/jquery-3.7.1.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <script>
        'use strict';

        window.crypto.randomUUID ??= function () {
            let random_numbers = new Uint8Array(16);
            window.crypto.getRandomValues(random_numbers);
            random_numbers[6] = 0x40 | (random_numbers[6] & 0x0f);
            random_numbers[8] = 0x80 | (random_numbers[8] & 0x3f);
            random_numbers = Array.from(random_numbers);
            return 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'.replaceAll('xx', s => random_numbers.shift().toString(16).padStart(2, '0'));
        }

        Map.groupBy ??= function (items, callbackFn) {
            const map = new Map();
            let i = 0;
            for (const item of items) {
                const key = callbackFn(item, i);
                map.set(key, (map.get(key) ?? []).concat([item]));
                ++i;
            }
            return map;
        }

        $.fn.extend({
            assign: function (data) {
                return $(this).each(function () {
                    ({
                        array: () => {
                            $(this)
                                .children(':not(template)')
                                .remove();
                            $(this)
                                .data({ data: data })
                                // template.clone() returns a document-fragment element.
                                // since the element will remove when it is appended to the main DOM,
                                // there will be no way to reference values later if they are assigned to the element.
                                // that means it needs to assign values to the child elements of the document-flagment.
                                .append(data.map(value => $($(this).children('template')[0].content).clone(true).children().assign(value)))
                                .find('[data-assign]')
                                .attr({ 'data-update': false });
                        },
                        object: () => $(this)
                            .data({ data: data })
                            .find('[data-assign]')
                            .each(function () {
                                $(this).assign(data[$(this).attr('data-assign')]);
                            }),
                        other: () => $(this)
                            .data({ data: data })
                            .each(function () {
                                return ({
                                    input: () => $(this).prop({
                                        checked: data !== undefined && data,
                                        indeterminate: data === undefined,
                                    })
                                }[this.tagName.toLowerCase()] ?? (() => $(this).text(data)))();
                            }),
                    })[(data instanceof Array || data instanceof Collection) ? 'array' : data instanceof Object ? 'object' : 'other']();
                });
            },
            nearest: function (callback) {
                for (let $element = this; $element.length > 0; $element = $element.parent()) {
                    for (let i = 0; i < $element.length; ++i) {
                        if (callback.apply($element[i])) {
                            return $($element[i]);
                        }
                    }
                }
                return $();
            },
        });

        class AttributeMutationObserver {
            #observer;

            constructor(attribute, callback) {
                this.#observer = new MutationObserver(records => {
                    callback([
                        ...records
                            .flatMap(record => Array
                                .from(record.addedNodes)
                                .flatMap(node => $([...$(node).filter(`[${attribute}]`).get(), ...$(node).find(`[${attribute}]`).get()]).get())
                                .map(target => ({
                                    type: 'addedNode',
                                    target: target,
                                    value: $(target).attr(attribute) ?? null,
                                    oldValue: null,
                                    record: record,
                                }))),
                        ...records
                            .flatMap(record => Array
                                .from(record.removedNodes)
                                .flatMap(node => $([...$(node).filter(`[${attribute}]`).get(), ...$(node).find(`[${attribute}]`).get()]).get())
                                .map(target => ({
                                    type: 'removedNode',
                                    target: target,
                                    value: $(target).attr(attribute) ?? null,
                                    oldValue: null,
                                    record: record,
                                }))),
                        ...records
                            .filter(({ attributeName }) => attributeName === attribute)
                            .map(record => ({
                                type: 'changedAttribute',
                                target: record.target,
                                value: $(record.target).attr(attribute) ?? null,
                                oldValue: record.oldValue,
                                record: record,
                            }))
                    ]);
                });
            }

            static {
                Reflect.ownKeys(MutationObserver.prototype)
                    .filter(name => !['constructor', Symbol.toStringTag].includes(name))
                    .forEach(name => this.prototype[name] = function (...args) {
                        this.#observer[name](...args);
                    });
            }
        }

        class ModelAssigner {
            static get $targets() {
                return $('[data-assign]');
            }

            static assign($targets = this.$targets) {
                $targets.each(function () {
                    $(this).assign(eval($(this).attr('data-assign')));
                });
            }

            static update($targets = this.$targets) {
                $targets
                    .filter(':not([data-update="false"])')
                    .each(function () {
                        $(this).assign(eval($(this).attr('data-assign')));
                    });
            }
        }

        class LiveNotification {
            static info(message, summary = '') {
                $('#liveNotificationPlaceholder').assign([{
                    message: message,
                    summary: summary,
                }]);
            }
        }

        class Action {
            constructor(event, $owner, $receiver) {
                this.event = event;
                this.$owner = $owner;
                this.$receiver = $receiver;
            }
            run() { }
            roleback() { }
        }
        class LoadPresetAction extends Action {
            run() {
                new WebModelLoader().load('./preset.json');
                LiveNotification.info('Preset was loaded.', 'Load preset');
            }
        }
        class RootPaneActions {
            static get containerId() {
                return `${this.name[0].toLowerCase()}${this.name.slice(1, -7)}`;
            }
            static get ShowAction() {
                const containerId = this.containerId;
                return class extends Action {
                    run() {
                        $(`#${containerId}`).css({ display: '' });
                    }
                };
            }
            static get HideAction() {
                const containerId = this.containerId;
                return class extends Action {
                    run() {
                        $(`#${containerId}`).queue(function () {
                            $(this).css({ display: 'none' });
                            $(this).dequeue();
                        })
                    }
                };
            }
        }
        class ShoppingListTabActions extends RootPaneActions {
            static get ToggleItemAction() {
                return class extends Action {
                    run() {
                        $(this.$owner.closest('form')).data('data').selected = this.$owner.prop('checked');
                    }
                }
            }
            static get CopyAction() {
                const myself = this;
                return class extends Action {
                    run() {
                        LiveNotification.info('The list was copied to the clipboard.', 'Copy');
                    }
                }
            }
        }
        class ItemSetTabActions extends RootPaneActions {
            static get ToggleItemSetAction() {
                return class extends Action {
                    run() {
                        $(this.$owner.closest('form')).data('data').selected = this.$owner.prop('checked');
                    }
                }
            }
        }
        class MainMenuActions extends RootPaneActions { }
        class VisualizeAction extends Action {
            run() {
                this.$owner.queue(function () {
                    $(this)
                        .css({ visibility: '' })
                        .dequeue();
                });
            }
        }
        class InvisualizeAction extends Action {
            run() {
                this.$owner.queue(async function () {
                    $(this)
                        .css({ visibility: 'hidden' })
                        .dequeue();
                });
            }
        }
        class HideTabAction extends Action {
            run() {
                $(this.$owner.closest('[data-role="root-pane"]')).css({ display: 'none' });
            }
        }
        class StopPropagationAction extends Action {
            run() {
                this.event.stopPropagation();
            }
        }
        class SlideoutToTopAction extends Action {
            run() {
                this.$owner.queue(async function () {
                    await this.animate({ translate: ['0 0', '0 -100%'] }, { duration: 200, fill: 'forwards' }).finished;
                    $(this).dequeue();
                });
            }
        }
        class SlideinToBottomAction extends Action {
            run() {
                this.$owner.queue(async function () {
                    await this.animate({ translate: ['0 -100%', '0 0'] }, { duration: 200, fill: 'forwards' }).finished;
                    $(this).dequeue();
                });
            }
        }

        class ActionSchema {
            constructor({ name, type, qualifiers = undefined }) {
                this.name = name;
                this.type = type;
                this.qualifiers = qualifiers;
            }

            inject(owner, receiver = this.preferredReceiver(owner)) {
                const injectedActions = $(owner).data('injectedActions') ?? [];
                if (injectedActions.find(action =>
                    action.name === this.name &&
                    action.type === this.type &&
                    action.qualifiers.every(qualifier => this.qualifiers.includes(qualifier)) &&
                    action.receiver === receiver)) {
                    return this;
                }

                const myself = this;
                const actionClass = eval(this.name
                    .split('.')
                    .map(name => `${name[0].toUpperCase()}${name.slice(1)}Actions`)
                    .join('.')
                    .slice(0, -1));
                const handler = function (event) {
                    if (myself.type === 'scroll') {
                        const newScrollTop = Math.min(Math.max(receiver.scrollTop, 0), receiver.scrollHeight - receiver.clientHeight);
                        const oldScrollTop = $(receiver).data('scrollTop');
                        if (newScrollTop !== oldScrollTop) {
                            $(receiver).data({
                                scrollTop: newScrollTop,
                                oldScrollTop: oldScrollTop,
                                scrollDirection: newScrollTop < oldScrollTop ? 'up' : 'down',
                                oldScrollDirection: $(receiver).data('scrollDirection'),
                            });
                        }
                        if (['up', 'down'].some(direction => myself.qualifiers.includes(direction)) && !myself.qualifiers.includes($(receiver).data('scrollDirection'))) {
                            return;
                        }
                        if (myself.qualifiers.includes('onlyfirsttime') && $(receiver).data('scrollDirection') === $(receiver).data('oldScrollDirection')) {
                            return;
                        }
                        console.log([oldScrollTop, newScrollTop, myself.name]);
                    }
                    new actionClass(event, $(owner), $(receiver)).run();
                    storage.save();
                    ModelAssigner.update();
                };
                $(receiver).bind(this.type, handler);
                $(owner).data({
                    injectedActions: injectedActions.concat([{
                        name: this.name,
                        type: this.type,
                        qualifiers: this.qualifiers,
                        owner: owner,
                        receiver: receiver,
                        handler: handler,
                    }])
                });

                return this;
            }

            preferredReceiver(owner) {
                if (this.type === 'scroll') {
                    return $(owner).nearest(function () {
                        return ['auto', 'scroll'].includes($(this).css('overflow'));
                    })[0];
                }
                return owner;
            }
        }
        class ActionSchemaArray extends Array {
            static parse(schema) {
                return this.from(schema
                    .matchAll(/([-\w]+) *: *\[?((?:[.\w]+)?(?:, *[.\w]+)*)(?![-\w]* *:)\]?,? */g))
                    .flatMap(match => match[2].split(',').map(action => new ActionSchema({
                        name: action.trim(),
                        type: match[1].split('-')[0],
                        qualifiers: match[1].split('-').slice(1),
                    })));
            }

            inject(owner) {
                this.forEach(schema => schema.inject(owner));
            }
        }
        class ActionMutationObserver {
            static #observer;

            static observe() {
                $('[data-action]').each(function () {
                    ActionSchemaArray.parse($(this).attr('data-action')).inject(this);
                })
                this.#observer = new AttributeMutationObserver('data-action', records => records
                    .filter(record => record.type === 'addedNode')
                    .forEach(({ target }) => ActionSchemaArray.parse($(target).attr('data-action')).inject(target)))
                    .observe($('body')[0], { subtree: true, childList: true });
            }

            static {
                Reflect.ownKeys(AttributeMutationObserver.prototype)
                    .filter(name => !['constructor', 'observe'])
                    .forEach(name => this[name] = function (...args) {
                        this.#observer[name](...args);
                    });
            }
        }

        function updateViews() {
            $('[data-assign]:not([data-update="false"])')
                .each(function () {
                    if ($(this).length > 0) $(this).assign(eval($(this).attr('data-assign')));
                });
        }

        class Collection {
            static {
                Reflect.ownKeys(Array.prototype)
                    .filter(name => !['copyWithin', 'fill', 'length', 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift', Symbol.unscopables].includes(name))
                    .forEach(name => this.prototype[name] = function (...args) {
                        return this.data[name](...args);
                    });
            }

            get length() {
                return this.data.length;
            }
        }
        class ObservableCollection extends Collection {
            constructor() {
                super();
                this.data = [];
                this.handlers = {};
            }

            bind(type, handler) {
                this.handlers[type] ??= [];
                this.handlers[type].push(handler);
                return this;
            }
            unbind(type, handler) {
                const index = this.handlers[type]?.indexOf(handler);
                if (index !== undefined && index != -1) {
                    this.handlers[type].splice(index, 1);
                }
                return this;
            }
            #callHandlers(type, event) {
                this.handlers[type]?.forEach(handler => handler.call(this, event));
            }

            insert(index, ...elements) {
                const event = {
                    target: this,
                    index: index,
                    elements: elements,
                };
                this.#callHandlers('beforeinsert', event);
                this.data.splice(index, 0, ...event.elements);
                this.#callHandlers('insert', { target: this, index: index, elements: event.elements });
                return this;
            }

            removeAt(index, count = Infinity) {
                if (index >= this.data.length || count === 0) return this;
                if (index < 0) {
                    index = Math.max(index + this.data.length, 0);
                }
                const removedElements = this.data.splice(index, count);
                this.#callHandlers('remove', { target: this, index: index, elements: removedElements });
                return this;
            }
            remove(...args) {
                args.forEach(element => {
                    for (let i = this.data.indexOf(element); i != -1; i = this.data.indexOf(element, i)) {
                        this.removeAt(i, 1);
                    }
                });
                return this;
            }
            removeAll() {
                return this.removeAt(0);
            }

            push(...elements) {
                return this.insert(this.data.length, ...elements);
            }
            pop() {
                const removedElement = this.data.at(-1);
                this.removeAt(-1, 1);
                return removedElement;
            }
        }
        class CollectionFilter extends Collection {
            constructor(collection, filter) {
                super();
                this.collection = collection;
                this.filter = filter;
            }

            get data() {
                return this.collection.filter(this.filter);
            }
        }
        class Entities extends ObservableCollection {
            constructor() {
                super();
                this.bind('beforeinsert', function (event) {
                    event.elements = event.elements.filter((element, index, self) => !event.target.includes(element) && index === self.indexOf(element));
                });
            }

            toJSON() {
                return [...this];
            }
        }
        class Item {
            constructor(properties = {}) {
                Object
                    .entries({ uuid: crypto.randomUUID(), name: '', amount: 0, unit: '', tags: [], displayed: false, selected: false })
                    .forEach(([key, value]) => this[key] = properties[key] ?? value);
            }
        }
        class BundledItem {
            constructor(items) {
                this.items = [...items];
            }

            get name() {
                return this.items[0]?.name;
            }
            get amount() {
                return this.items.reduce((total, { amount }) => amount + total, 0);
            }
            get unit() {
                return this.items[0]?.unit;
            }
            get tags() {
                return this.items.flatMap(({ tags }) => tags).filter((tag, index, self) => self.indexOf(tag) === index).sort();
            }
            get displayed() {
                const count = this.items.reduce((total, { displayed }) => total + displayed, 0);
                return (count < 0 && count < this.items.length) ? undefined : count !== 0;
            }
            get selected() {
                const count = this.items.reduce((total, { selected }) => total + selected, 0);
                return 0 < count && count < this.items.length ? undefined : count !== 0;
            }
            set selected(state) {
                this.items.forEach(item => item.selected = state);
            }
        }
        class BundledItems extends Collection {
            constructor(collection) {
                super();
                this.collection = collection;
            }

            get data() {
                // it needs to convert the iterator to an array because iOS Safari does not support Iterator#map. 
                return Array.from(Map.groupBy(this.collection, ({ name, unit }) => `name="${name}",unit="${unit}"`).values())
                    .map(items => new BundledItem(items));
            }
        }
        class Items extends ObservableCollection {
            constructor() {
                super();
                this
                    .bind('beforeinsert', function (event) {
                        event.elements = event.elements.filter((element, index, self) => !event.target.includes(element) && index === self.indexOf(element));
                    })
                    .bind('remove', function (event) {
                        model.itemSets.forEach(({ items }) => items.remove(...event.elements));
                    });
            }

            get displays() {
                return new class extends CollectionFilter {
                    constructor(collection, filter) {
                        super(collection, filter);
                    }

                    get bundles() {
                        return new BundledItems(this);
                    }
                }(this, ({ displayed }) => displayed);
            }

            get selections() {
                return new CollectionFilter(this, ({ selected }) => selected);
            }
        }
        class ItemSet {
            constructor(properties = {}) {
                Object
                    .entries({ name: '', items: [] })
                    .forEach(([key, value]) => this[key] = properties[key] ?? value);
            }
        }

        class Model {
            constructor() {
                this.itemSets = [];
                this.draftItemSet = undefined;
                this.independentItems = [];
                this.draftIndependentItem = undefined;
            }

            get items() {
                return new Items(...this.itemSets.flatMap(itemSet => itemSet.items), ...this.independentItems);
            }

            commitDraftItemSet() {
                this.itemSets.push(draftItemSet);
                this.draftItemSet = undefined;
            }
            discardDraftItemSet() {
                this.draftItemSet = undefined;
            }
            
            commitDraftIndependentItem() {
                this.independentItems.push(draftIndependentItem);
                this.draftIndependentItem = undefined;
            }
            discardDraftIndependentItem() {
                this.draftIndependentItem = undefined;
            }

            save() {
                localStorage['model'] = JSON.stringify(this);
                return this;
            }
            load() {
                Object.assign(this, JSON.parse(localStorage['model']));
                return this;
            }
        }
    </script>
</body>

</html>